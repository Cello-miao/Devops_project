---
# GitLab CI/CD Pipeline for DevOps Project

stages:
  - build
  - test
  - push
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"

services:
  - docker:27-dind

cache:
  paths:
    - frontend/node_modules/
    - backend/_build/
    - backend/deps/

before_script:
  - docker info || true

# Build frontend Docker image
build_frontend:
  stage: build
  image: docker:27
  script:
    - docker build -t "$CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA"
      -f frontend/Dockerfile frontend/
  only:
    - branches

# Build backend Docker image
build_backend:
  stage: build
  image: docker:27
  script:
    - docker build -t "$CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA"
      -f backend/Dockerfile backend/
  only:
    - branches

# Test backend with Elixir
test_backend:
  stage: test
  image: elixir:1.17-alpine
  services:
    - name: postgres:15-alpine
      alias: postgres
  variables:
    POSTGRES_DB: signin_project_test
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    POSTGRES_HOST_AUTH_METHOD: trust
    DB_HOST: postgres
    DB_USER: postgres
    DB_PASSWORD: postgres
    DB_NAME: signin_project_test
    MIX_ENV: test
  script:
    - apk add --no-cache build-base git postgresql-client
    - echo "Waiting for postgres to be ready..."
    - until pg_isready -h postgres -U postgres; do sleep 1; done
    - cd backend
    - mix local.hex --force
    - mix local.rebar --force
    - mix deps.get
    - mix ecto.create
    - mix ecto.migrate
    - mix test
  only:
    - branches

# Test frontend with Node.js
test_frontend:
  stage: test
  image: node:20-alpine
  script:
    - cd frontend
    - npm ci
    - npm run test --if-present
  only:
    - branches

# Build and push images to registry (main branch only)
push_frontend:
  stage: push
  image: docker:27
  script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login
      -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
    - docker build -t "$CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA"
      -t "$CI_REGISTRY_IMAGE/frontend:latest"
      -f frontend/Dockerfile frontend/
    - docker push "$CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA"
    - docker push "$CI_REGISTRY_IMAGE/frontend:latest"
  only:
    - main

push_backend:
  stage: push
  image: docker:27
  script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login
      -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
    - docker build -t "$CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA"
      -t "$CI_REGISTRY_IMAGE/backend:latest"
      -f backend/Dockerfile backend/
    - docker push "$CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA"
    - docker push "$CI_REGISTRY_IMAGE/backend:latest"
  only:
    - main

# Deploy to EC2 production server
deploy_prod:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client
    - mkdir -p ~/.ssh
    - echo "$SSH_KEY_BASE64" | base64 -d > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - ssh-keyscan -H $EC2_HOST >> ~/.ssh/known_hosts 2>/dev/null || true
  script:
    - echo "Starting deployment to EC2..."
    - ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "mkdir -p app"
    # 1. Upload configuration files
    - echo "Step 1: Uploading configuration files..."
    - cat docker-compose.prod.yml | ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "cat > app/docker-compose.prod.yml"
    - cat nginx.conf | ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "cat > app/nginx.conf"
    # 2. Create .env.prod file
    - echo "Step 2: Creating .env.prod file..."
    - |
      ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "cat > app/.env.prod" << EOF
      # Production Environment Configuration (Generated by GitLab CI/CD)
      # Database Configuration
      POSTGRES_USER=postgres
      POSTGRES_PASSWORD=$DB_PASSWORD
      POSTGRES_DB=signin_project_prod

      # Backend Configuration
      SECRET_KEY_BASE=$SECRET_KEY_BASE
      PHX_SERVER=true
      MIX_ENV=prod

      # Database Connection
      DB_HOST=db
      DB_USER=postgres
      DB_PASSWORD=$DB_PASSWORD
      DB_NAME=signin_project_prod

      # Docker Images (from GitLab CI/CD)
      BACKEND_IMAGE=$CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA
      FRONTEND_IMAGE=$CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA
      EOF
    # 3. Login to Registry
    - echo "Step 3: Logging in to Docker Registry..."
    - ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST
      "echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER
      --password-stdin $CI_REGISTRY"
    # 4. Pull images
    - echo "Step 4: Pulling latest images..."
    - ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST
      "cd app && docker compose -f docker-compose.prod.yml --env-file .env.prod pull"
    # 5. Start services
    - echo "Step 5: Starting containers..."
    - ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST
      "cd app && docker compose -f docker-compose.prod.yml --env-file .env.prod up -d"
    # 6. Wait for services and verify health
    - echo "Step 6: Waiting for services to start..."
    - sleep 10
    - echo "Verifying service health..."
    - |
      ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
        cd app
        # Check if backend container is running
        if ! docker compose -f docker-compose.prod.yml --env-file .env.prod ps backend | grep -q 'Up'; then
          echo 'Error: Backend container failed to start'
          docker compose -f docker-compose.prod.yml --env-file .env.prod logs backend
          exit 1
        fi
        echo 'Backend container is running'

        # Check database connection
        echo 'Checking database connection...'
        if ! docker compose -f docker-compose.prod.yml --env-file .env.prod exec -T db pg_isready -U postgres; then
          echo 'Error: Database is not ready'
          docker compose -f docker-compose.prod.yml --env-file .env.prod logs db
          exit 1
        fi
        echo 'Database connection is healthy'
      "
    # 7. Run database migrations
    - echo "Step 7: Running database migrations..."
    - |
      ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
        cd app
        echo 'Starting database migration...'

        # Attempt to run migrations
        if docker compose -f docker-compose.prod.yml --env-file .env.prod \
          exec -T backend /app/bin/signin_project eval 'SigninProject.Release.migrate()'; then
          echo 'Database migration completed successfully'
        else
          MIGRATE_EXIT_CODE=\$?
          echo 'Migration returned exit code: '\$MIGRATE_EXIT_CODE

          # Check migration status
          echo 'Checking migration status...'
          docker compose -f docker-compose.prod.yml --env-file .env.prod \
            exec -T backend /app/bin/signin_project eval 'Ecto.Migrator.migrated_versions(SigninProject.Repo) |> IO.inspect(label: \"Completed migrations\")'

          # Show recent logs for debugging
          echo '=== Recent Backend Logs ==='
          docker compose -f docker-compose.prod.yml --env-file .env.prod logs --tail=50 backend

          # Log warning but continue deployment
          if [ \$MIGRATE_EXIT_CODE -ne 0 ]; then
            echo 'Database migration failed, but continuing deployment (manual check may be required)'
            # Do not exit, allow deployment to continue with warning
          fi
        fi
      "
    # 8. Verify deployment
    - echo "Step 8: Verifying deployment..."
    - ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST
      "cd app && docker compose -f docker-compose.prod.yml --env-file .env.prod ps"
    - echo "Deployment completed!"
    - echo "Frontend: http://$EC2_HOST"
    - echo "Backend API: http://$EC2_HOST/api"
  environment:
    name: production
    url: http://$EC2_HOST
  only:
    - main
  needs:
    - push_frontend
    - push_backend
