---
# GitLab CI/CD Pipeline for DevOps Project

stages:
  - build
  - test
  - push
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"

services:
  - docker:27-dind

cache:
  paths:
    - frontend/node_modules/
    - backend/_build/
    - backend/deps/

before_script:
  - docker info || true

# Build frontend Docker image
build_frontend:
  stage: build
  image: docker:27
  script:
    - docker build -t "$CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA"
      -f frontend/Dockerfile frontend/
  only:
    - branches

# Build backend Docker image
build_backend:
  stage: build
  image: docker:27
  script:
    - docker build -t "$CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA"
      -f backend/Dockerfile backend/
  only:
    - branches

# Test backend with Elixir
test_backend:
  stage: test
  image: elixir:1.17-alpine
  services:
    - name: postgres:15-alpine
      alias: postgres
  variables:
    POSTGRES_DB: signin_project_test
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    POSTGRES_HOST_AUTH_METHOD: trust
    DB_HOST: postgres
    DB_USER: postgres
    DB_PASSWORD: postgres
    DB_NAME: signin_project_test
    MIX_ENV: test
  script:
    - apk add --no-cache build-base git postgresql-client
    - echo "Waiting for postgres to be ready..."
    - until pg_isready -h postgres -U postgres; do sleep 1; done
    - cd backend
    - mix local.hex --force
    - mix local.rebar --force
    - mix deps.get
    - mix ecto.create
    - mix ecto.migrate
    - mix test
  only:
    - branches

# Test frontend with Node.js
test_frontend:
  stage: test
  image: node:20-alpine
  script:
    - cd frontend
    - npm ci
    - npm run test --if-present
  only:
    - branches

# Build and push images to registry (main branch only)
push_frontend:
  stage: push
  image: docker:27
  script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login
      -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
    - docker build -t "$CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA"
      -t "$CI_REGISTRY_IMAGE/frontend:latest"
      -f frontend/Dockerfile frontend/
    - docker push "$CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA"
    - docker push "$CI_REGISTRY_IMAGE/frontend:latest"
  only:
    - main

push_backend:
  stage: push
  image: docker:27
  script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login
      -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
    - docker build -t "$CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA"
      -t "$CI_REGISTRY_IMAGE/backend:latest"
      -f backend/Dockerfile backend/
    - docker push "$CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA"
    - docker push "$CI_REGISTRY_IMAGE/backend:latest"
  only:
    - main

# Deploy to EC2 production server
deploy_prod:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client
    - mkdir -p ~/.ssh
    - echo "$SSH_KEY_BASE64" | base64 -d > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - ssh-keyscan -H $EC2_HOST >> ~/.ssh/known_hosts 2>/dev/null || true
  script:
    - echo "开始部署到 EC2..."
    - ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "mkdir -p app"
    # 1. 上传配置文件
    - echo "步骤1 上传配置文件..."
    - cat docker-compose.prod.yml | ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "cat > app/docker-compose.prod.yml"
    - cat nginx.conf | ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "cat > app/nginx.conf"
    # 2. 配置环境变量
    - echo "步骤2 配置环境变量..."
    - ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST
      "cd app &&
      export FRONTEND_IMAGE=$CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA &&
      export BACKEND_IMAGE=$CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA &&
      export DB_PASSWORD=$DB_PASSWORD &&
      export POSTGRES_PASSWORD=$DB_PASSWORD"
    # 3. 登录到 Registry
    - echo "步骤3 登录到 Docker Registry..."
    - ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST
      "echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER
      --password-stdin $CI_REGISTRY"
    # 4. 拉取镜像
    - echo "步骤4 拉取最新镜像..."
    - ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST
      "cd app &&
      export FRONTEND_IMAGE=$CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA &&
      export BACKEND_IMAGE=$CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA &&
      docker compose -f docker-compose.prod.yml pull"
    # 5. 启动服务
    - echo "步骤5 启动容器..."
    - ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST
      "cd app &&
      export FRONTEND_IMAGE=$CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA &&
      export BACKEND_IMAGE=$CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA &&
      export DB_PASSWORD=$DB_PASSWORD &&
      export POSTGRES_PASSWORD=$DB_PASSWORD &&
      export SECRET_KEY_BASE=$SECRET_KEY_BASE &&
      docker compose -f docker-compose.prod.yml up -d"
    # 6. 等待服务启动
    - echo "步骤6 等待服务启动..."
    - sleep 10
    # 7. 运行数据库迁移
    - echo "步骤7 运行数据库迁移..."
    - ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST
      "cd app && docker compose -f docker-compose.prod.yml
      exec -T backend mix ecto.migrate ||
      echo '迁移跳过（可能已运行）'"
    # 8. 查看容器状态
    - echo "步骤8 验证部署..."
    - ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST
      "cd app && docker compose -f docker-compose.prod.yml ps"
    - echo "部署完成！"
    - echo "前端 http://$EC2_HOST"
    - echo "后端 http://$EC2_HOST:4000/api/health"
  environment:
    name: production
    url: http://$EC2_HOST
  only:
    - main
  needs:
    - push_frontend
    - push_backend
