---
# GitLab CI/CD Pipeline for DevOps Project

stages:
  - build
  - test
  - push
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"

services:
  - docker:27-dind

cache:
  paths:
    - frontend/node_modules/
    - backend/_build/
    - backend/deps/

before_script:
  - docker info || true

# Build frontend Docker image
build_frontend:
  stage: build
  image: docker:27
  script:
    - docker build -t "$CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA"
      -f frontend/Dockerfile frontend/
  only:
    - branches

# Build backend Docker image
build_backend:
  stage: build
  image: docker:27
  script:
    - docker build -t "$CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA"
      -f backend/Dockerfile backend/
  only:
    - branches

# Test backend with Elixir
test_backend:
  stage: test
  image: elixir:1.17-alpine
  services:
    - name: postgres:15-alpine
      alias: postgres
  variables:
    POSTGRES_DB: signin_project_test
    POSTGRES_USER: postgres
    POSTGRES_PASSWORD: postgres
    POSTGRES_HOST_AUTH_METHOD: trust
    DB_HOST: postgres
    DB_USER: postgres
    DB_PASSWORD: postgres
    DB_NAME: signin_project_test
    MIX_ENV: test
  script:
    - apk add --no-cache build-base git postgresql-client
    - echo "Waiting for postgres to be ready..."
    - until pg_isready -h postgres -U postgres; do sleep 1; done
    - cd backend
    - mix local.hex --force
    - mix local.rebar --force
    - mix deps.get
    - mix ecto.create
    - mix ecto.migrate
    - mix test
  only:
    - branches

# Test frontend with Node.js
test_frontend:
  stage: test
  image: node:20-alpine
  script:
    - cd frontend
    - npm ci
    - npm run test --if-present
  only:
    - branches

# Build and push images to registry (main branch only)
push_frontend:
  stage: push
  image: docker:27
  script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login
      -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
    - docker build -t "$CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA"
      -t "$CI_REGISTRY_IMAGE/frontend:latest"
      -f frontend/Dockerfile frontend/
    - docker push "$CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA"
    - docker push "$CI_REGISTRY_IMAGE/frontend:latest"
  only:
    - main

push_backend:
  stage: push
  image: docker:27
  script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login
      -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
    - docker build -t "$CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA"
      -t "$CI_REGISTRY_IMAGE/backend:latest"
      -f backend/Dockerfile backend/
    - docker push "$CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA"
    - docker push "$CI_REGISTRY_IMAGE/backend:latest"
  only:
    - main

# Deploy to EC2 production server
deploy_prod:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache openssh-client
    - mkdir -p ~/.ssh
    - echo "$SSH_KEY_BASE64" | base64 -d > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    - ssh-keyscan -H $EC2_HOST >> ~/.ssh/known_hosts 2>/dev/null || true
  script:
    - echo "开始部署到 EC2..."
    - ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "mkdir -p app"
    # 1. 上传配置文件
    - echo "步骤1 上传配置文件..."
    - cat docker-compose.prod.yml | ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "cat > app/docker-compose.prod.yml"
    - cat nginx.conf | ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "cat > app/nginx.conf"
    # 2. 创建 .env.prod 文件
    - echo "步骤2 创建 .env.prod 文件..."
    - |
      ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "cat > app/.env.prod" << EOF
      # Production Environment Configuration (Generated by GitLab CI/CD)
      # Database Configuration
      POSTGRES_USER=postgres
      POSTGRES_PASSWORD=$DB_PASSWORD
      POSTGRES_DB=signin_project_prod
      
      # Backend Configuration
      SECRET_KEY_BASE=$SECRET_KEY_BASE
      PHX_SERVER=true
      MIX_ENV=prod
      
      # Database Connection
      DB_HOST=db
      DB_USER=postgres
      DB_PASSWORD=$DB_PASSWORD
      DB_NAME=signin_project_prod
      
      # Docker Images (from GitLab CI/CD)
      BACKEND_IMAGE=$CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA
      FRONTEND_IMAGE=$CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA
      EOF
    # 3. 登录到 Registry
    - echo "步骤3 登录到 Docker Registry..."
    - ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST
      "echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER
      --password-stdin $CI_REGISTRY"
    # 4. 拉取镜像
    - echo "步骤4 拉取最新镜像..."
    - ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST
      "cd app && docker compose -f docker-compose.prod.yml --env-file .env.prod pull"
    # 5. 启动服务
    - echo "步骤5 启动容器..."
    - ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST
      "cd app && docker compose -f docker-compose.prod.yml --env-file .env.prod up -d"
    # 6. 等待服务启动并验证健康状态
    - echo "步骤6 等待服务启动..."
    - sleep 10
    - echo "验证服务健康状态..."
    - |
      ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
        cd app
        # 检查 backend 容器是否正在运行
        if ! docker compose -f docker-compose.prod.yml --env-file .env.prod ps backend | grep -q 'Up'; then
          echo '❌ 错误: Backend 容器未正常启动'
          docker compose -f docker-compose.prod.yml --env-file .env.prod logs backend
          exit 1
        fi
        echo '✅ Backend 容器运行正常'
        
        # 检查数据库连接
        echo '检查数据库连接...'
        if ! docker compose -f docker-compose.prod.yml --env-file .env.prod exec -T db pg_isready -U postgres; then
          echo '❌ 错误: 数据库未就绪'
          docker compose -f docker-compose.prod.yml --env-file .env.prod logs db
          exit 1
        fi
        echo '✅ 数据库连接正常'
      "
    # 7. 运行数据库迁移
    - echo "步骤7 运行数据库迁移..."
    - |
      ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST "
        cd app
        echo '开始数据库迁移...'
        
        # 尝试运行迁移
        if docker compose -f docker-compose.prod.yml --env-file .env.prod \
          exec -T backend /app/bin/signin_project eval 'SigninProject.Release.migrate()'; then
          echo '✅ 数据库迁移成功完成'
        else
          MIGRATE_EXIT_CODE=\$?
          echo '⚠️  数据库迁移返回错误码: '\$MIGRATE_EXIT_CODE
          
          # 检查是否是因为迁移已经运行过
          echo '检查迁移状态...'
          docker compose -f docker-compose.prod.yml --env-file .env.prod \
            exec -T backend /app/bin/signin_project eval 'Ecto.Migrator.migrated_versions(SigninProject.Repo) |> IO.inspect(label: \"已完成的迁移\")'
          
          # 显示最近的日志帮助调试
          echo '=== Backend 最近日志 ==='
          docker compose -f docker-compose.prod.yml --env-file .env.prod logs --tail=50 backend
          
          # 如果退出码不是 0，说明有真正的错误
          if [ \$MIGRATE_EXIT_CODE -ne 0 ]; then
            echo '❌ 数据库迁移失败，但继续部署（可能需要手动检查）'
            # 不退出，允许部署继续，但记录警告
          fi
        fi
      "
    # 8. 查看容器状态
    - echo "步骤8 验证部署..."
    - ssh -o StrictHostKeyChecking=no $EC2_USER@$EC2_HOST
      "cd app && docker compose -f docker-compose.prod.yml --env-file .env.prod ps"
    - echo "部署完成！"
    - echo "前端 http://$EC2_HOST"
    - echo "后端 http://$EC2_HOST/api"
  environment:
    name: production
    url: http://$EC2_HOST
  only:
    - main
  needs:
    - push_frontend
    - push_backend
